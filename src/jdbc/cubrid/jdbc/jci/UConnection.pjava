/*
 * Copyright (C) 2008 Search Solution Corporation. All rights reserved by Search Solution. 
 *
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met: 
 *
 * - Redistributions of source code must retain the above copyright notice, 
 *   this list of conditions and the following disclaimer. 
 *
 * - Redistributions in binary form must reproduce the above copyright notice, 
 *   this list of conditions and the following disclaimer in the documentation 
 *   and/or other materials provided with the distribution. 
 *
 * - Neither the name of the <ORGANIZATION> nor the names of its contributors 
 *   may be used to endorse or promote products derived from this software without 
 *   specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
 * OF SUCH DAMAGE. 
 *
 */

/**
 * Title:        CUBRID Java Client Interface<p>
 * Description:  CUBRID Java Client Interface<p>
 * @version 2.0
 */

package cubrid.jdbc.jci;

import java.net.Socket;
import java.net.InetAddress;
import java.util.Vector;
import java.io.*;
import javax.transaction.xa.Xid;
import cubrid.sql.CUBRIDOID;
import cubrid.jdbc.driver.CUBRIDDriver;
import cubrid.jdbc.driver.CUBRIDXid;
import cubrid.jdbc.driver.CUBRIDConnection;
import cubrid.jdbc.driver.CUBRIDException; 
#ifdef SERVER_SIDE_JDBC
import com.cubrid.jsp.ExecuteThread;
import com.cubrid.jsp.Server;
#endif

#ifdef SEND_APP_INFO
import cubrid.jdbc.driver.CUBRIDJdbcInfoTable;
#endif

/*
 * class UConnection은 CAS와의 connection을 만들고 Transaction을 관리한다.또한
 * SQL Statement를 prepare하며 여러가지의 DB 정보를 가져오거나 Set할 수 있다.
 *
 * 모든 public interface는 method 수행 중에 발생한 error를 UError object인
 * errorHandler에 set한다. 따라서 UConnection의 public interface를 호출할 때에는
 * 반드시 method getRecentError()를 call하여 error를 check하여야 한다.
 *
 * Internal Note
 *
 * flag isClosed를 가지고 있어 CAS와의 Connection이 끊어졌을 때 method들이 call될
 * 때에는 Error를 Set한다.
 * endTransaction(commit or rollback)을 할경우 CAS로부터 connection이 단절되므로
 * flag needReconnection을 가지고 이를 check하고 connection이 끊겼을 경우 다시
 * CAS와의 connection을 만든다.
 * oid관련 interface에 argument로 넘어오는 oid string은
 * '@page_id|slot_id|volumn_id'
 * format이어야 한다.
 *
 * Connection Mechanism
 *
 * server와의 connect 단계를 Driver Info를 보내는 단계와 Db Info를 보내는 단계로
 * 나누어 Driver Info를 보낸 후 새 port가 넘어올 경우 새로운 port로 다시
 * connect하도록 한다.

 * since 1.0
 */

public class UConnection
{
  public final static byte DBMS_CUBRID = 1;

  /* prepare flags */
  public final static byte PREPARE_INCLUDE_OID = 0x01;
  public final static byte PREPARE_UPDATABLE = 0x02;
  public final static byte PREPARE_CALL = 0x40;

  public final static byte DROP_BY_OID = 1, IS_INSTANCE = 2,
      GET_READ_LOCK_BY_OID = 3, GET_WRITE_LOCK_BY_OID = 4,
      GET_CLASS_NAME_BY_OID = 5, IS_GLO_INSTANCE = 6;

  public final static int OID_BYTE_SIZE = 8;

  public final static byte GLO_CMD_READ_DATA = 1, GLO_CMD_WRITE_DATA = 2,
      GLO_CMD_INSERT_DATA = 3, GLO_CMD_DELETE_DATA = 4,
      GLO_CMD_TRUNCATE_DATA = 5, GLO_CMD_APPEND_DATA = 6,
      GLO_CMD_DATA_SIZE = 7, GLO_CMD_COMPRESS_DATA = 8,
      GLO_CMD_DESTROY_DATA = 9, GLO_CMD_LIKE_SEARCH = 10,
      GLO_CMD_REG_SEARCH = 11, GLO_CMD_BINARY_SEARCH = 12;

  public final static byte GLO_NEW_TYPE_LO = 1, GLO_NEW_TYPE_FBO = 2;

  private final static String magicString = "CUBRK";
  private final static byte CAS_CLIENT_JDBC = 3; /*
                                                  * this value is defined in
                                                  * broker/cas_protocol.h
                                                  */

  private final static byte GET_COLLECTION_VALUE = 1,
      GET_SIZE_OF_COLLECTION = 2, DROP_ELEMENT_IN_SET = 3,
      ADD_ELEMENT_TO_SET = 4, DROP_ELEMENT_IN_SEQUENCE = 5,
      INSERT_ELEMENT_INTO_SEQUENCE = 6, PUT_ELEMENT_ON_SEQUENCE = 7;
  private final static int DB_PARAM_ISOLATION_LEVEL = 1,
      DB_PARAM_LOCK_TIMEOUT = 2, DB_PARAM_AUTO_COMMIT = 4;

  /* end_tran constants */
  private final static byte END_TRAN_COMMIT = 1;
  private final static byte END_TRAN_ROLLBACK = 2;

  private final static byte CON_STATUS_OUT_TRAN = 0, CON_STATUS_IN_TRAN = 1;

  private final static int LOCK_TIMEOUT_NOT_USED = -2;
  private final static int LOCK_TIMEOUT_INFINITE = -1;

  String conCharsetName;
  UOutputBuffer outBuffer;
  CUBRIDConnection cubridcon;

  boolean update_executed; /* for result cache */

  private OutputStream out;
  private InputStream in;
  private boolean needReconnection;
  private DataInputStream input;
  private DataOutputStream output;
  private String CASIp;
  private int CASPort;
  private int processId;
  private Socket client;
  private UError errorHandler;
  private Vector transactionList;
  private boolean isClosed = false;
  private byte[] dbInfo;
  private int lastIsolationLevel;
  private int lastLockTimeout = LOCK_TIMEOUT_NOT_USED;
  private boolean lastAutoCommit = true;
  private String dbname, user, passwd;
  // jci 3.0
  private byte[] broker_info = null;
  private byte con_status = CON_STATUS_OUT_TRAN;

  private boolean isServerSideJdbc = false;
  #ifdef SERVER_SIDE_JDBC
  private ExecuteThread curThread;
  #endif
  private byte[] checkCasMsg = null;
  int delayed_close_handle = 0;
  boolean skip_checkcas;
  boolean need_checkcas;
  Vector pooled_ustmts;

  private UUrlCache url_cache = null;
  private boolean isAutoCommitBySelf = false;

  private static byte[] driverInfo;

  static
  {
    driverInfo = new byte[10];
    UJCIUtil.copy_byte(driverInfo, 0, 5, magicString);
    driverInfo[5] = CAS_CLIENT_JDBC;
    driverInfo[6] = CUBRIDDriver.major_version;
    driverInfo[7] = CUBRIDDriver.minor_version;
    ;
    driverInfo[8] = CUBRIDDriver.patch_version;
    ;
  }

  /*
   * the normal constructor of the class UConnection
   */

  UConnection(String ip, int port, String dbname, String user, String passwd)
      throws CUBRIDException
  {
    CASIp = ip;
    CASPort = port;
    this.dbname = dbname;
    this.user = user;
    this.passwd = passwd;
    update_executed = false;

    needReconnection = true;
    conCharsetName = UJCIManager.sysCharsetName;

    String version = getDatabaseProductVersion();
    UError cpErr = errorHandler;
    endTransaction(true);
    if (version == null)
    {
      throw new CUBRIDException(cpErr);
    }
  }

  /*
   * the constructor of the class UConnection for class UStatement method cancel
   */

  UConnection(String ip, int port) throws UJciException
  {
    errorHandler = new UError();
    CASIp = ip;
    CASPort = port;
    initConnection(ip, port);
    needReconnection = false;
    conCharsetName = UJCIManager.sysCharsetName;
  }

#ifdef SERVER_SIDE_JDBC
  UConnection(Socket socket, ExecuteThread curThread) throws CUBRIDException
  {
    errorHandler = new UError();
    try
    {
      initConnection(socket);
      needReconnection = false;
      con_status = CON_STATUS_IN_TRAN;
      conCharsetName = UJCIManager.sysCharsetName;
      isServerSideJdbc = true;
      lastAutoCommit = false;
      this.curThread = curThread;
      curThread.setCharSet(conCharsetName);
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
      throw new CUBRIDException(errorHandler);
    }
  }

#endif

  private void initConnection(Socket socket) throws UJciException
  {
    try
    {
      client = socket;
      client.setTcpNoDelay(true);

      out = client.getOutputStream();
      output = new DataOutputStream(client.getOutputStream());
      output.writeInt(0x08);
      out.flush();
      output.flush();

      in = client.getInputStream();
      input = new DataInputStream(client.getInputStream());
    }
    catch (IOException e)
    {
      throw new UJciException(UErrorCode.ER_CONNECTION);
    }
  }

  public void setCharset(String newCharsetName)
      throws java.io.UnsupportedEncodingException
  {
    if (newCharsetName == null)
      return;
    byte[] b = { 0 };
    String s = new String(b, newCharsetName);

    conCharsetName = newCharsetName;

#ifdef SERVER_SIDE_JDBC
    if (isServerSideJdbc)
      curThread.setCharSet(conCharsetName);
#endif
  }

  public String getCharset()
  {
    return conCharsetName;
  }

  /*
   * oidString에 해당되는 object instance의 attribute name이 attributeName인 set
   * type attribute에 value를 element로 add한다. Error Code : ER_IS_CLOSED,
   * ER_ILLEGAL_DATA_SIZE, ER_INVALID_ARGUMENT, ER_COMMUNICATION
   */

  synchronized public void addElementToSet(CUBRIDOID oid, String attributeName,
      Object value)
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }
    try
    {
      manageElementOfSet(oid, attributeName, value, this.ADD_ELEMENT_TO_SET);
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
      return;
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
      return;
    }
  }

  /*
   * Statement의 batch execute를 위한 interface이다. BatchSqlStmt list를 batch
   * execute하며 각 statement의 결과는 integer array로 return되어 진다. result
   * value는 각 statement가 success한 경우 result count(0이상)를 나타내고 fail인
   * 경우 -3값을 갖는다. BatchSqlStmt[I]가 "q1;q2;…;qn"과 같을 때 q1만이
   * execute되며 q2,…,qn은 무시된다. BatchSqlStmt가 null이면
   * ER_INVALID_ARGUMENT error가 set된다. Error Code : ER_IS_CLOSED,
   * ER_INVALID_ARGUMENT, ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public UBatchResult batchExecute(String batchSqlStmt[])
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return null;
    }
    if (batchSqlStmt == null)
    {
      errorHandler.setErrorCode(UErrorCode.ER_INVALID_ARGUMENT);
      return null;
    }
    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return null;

      outBuffer.newRequest(out, UFunctionCode.EXECUTE_BATCH_STATEMENT);
      outBuffer.addByte(getAutoCommit() ? (byte) 1 : (byte) 0);

      for (int i = 0; i < batchSqlStmt.length; i++)
      {
        if (batchSqlStmt[i] != null)
          outBuffer.addStringWithNull(batchSqlStmt[i]);
        else
          outBuffer.addNull();
      }

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      int result;
      UBatchResult batchResult = new UBatchResult(inBuffer.readInt());
      for (int i = 0; i < batchResult.getResultNumber(); i++)
      {
        batchResult.setStatementType(i, inBuffer.readByte());
        result = inBuffer.readInt();
        if (result < 0)
          batchResult.setResultError(i, result, inBuffer.readString(inBuffer
              .readInt(), UJCIManager.sysCharsetName));
        else
        {
          batchResult.setResult(i, result);
          // jci 3.0
          inBuffer.readInt();
          inBuffer.readShort();
          inBuffer.readShort();
        }
      }

      transactionList.add(null);
      update_executed = true;
      return batchResult;
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
    return null;
  }

  /*
   * CAS와의 connection을 close한다. 현재 transaction list에 statement를 가지고
   * 있다면 transaction을 rollback하고 각 statement들을 close한 다음
   * connection을 close한다. Error Code : ER_IS_CLOSED, ER_COMMUNICATION
   */

  synchronized public void close()
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }
    // jci 3.0
    clearTransactionList();
    transactionList = null;
    if (client != null)
    {
      disconnect();
    }
    /*
     * jci 2.x if (transactionList != null && transactionList.size() > 0)
     * endTransaction(false);
     */

    if (!isServerSideJdbc)
    {
      try
      {
        if (client != null)
          clientSocketClose();
      }
      catch (IOException e)
      {
        errorHandler.setErrorMessage(UErrorCode.ER_COMMUNICATION, e
            .getMessage()
            + "in close");
      }
    }
    // System.gc();
    // UJCIManager.deleteInList(this);
    isClosed = true;
  }

  /*
   * oidString에 해당되는 object instance의 attribute name이 attributeName인
   * sequence type attribute의 index번째 element를 drop한다. Error Code :
   * ER_IS_CLOSED, ER_INVALID_ARGUMENT, ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public void dropElementInSequence(CUBRIDOID oid,
      String attributeName, int index)
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }
    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return;

      outBuffer.newRequest(out, UFunctionCode.RELATED_TO_COLLECTION);
      outBuffer.addByte(this.DROP_ELEMENT_IN_SEQUENCE);
      outBuffer.addOID(oid);
      outBuffer.addInt(index);
      if (attributeName == null)
        outBuffer.addNull();
      else
        outBuffer.addStringWithNull(attributeName);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
  }

  /*
   * oidString에 해당되는 object instance의 attribute name이 attributeName인 set
   * type attribute에 value에 해당되는 element를 drop한다. Error Code :
   * ER_IS_CLOSED, ER_INVALID_ARGUMENT, ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public void dropElementInSet(CUBRIDOID oid,
      String attributeName, Object value)
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }
    try
    {
      manageElementOfSet(oid, attributeName, value, this.DROP_ELEMENT_IN_SET);
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
      return;
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
      return;
    }
  }

  /*
   * Transaction을 commit하거나 rollback한다. commit나 rollback이 이루어지면
   * 관련된 모든 statement와 connection은 close되며 CAS와의 connection이
   * 끊어진다. Error Code : ER_IS_CLOSED, ER_UNKNOWN, ER_ILLEGAL_DATA_SIZE,
   * ER_COMMUNICATION
   */

  synchronized public void endTransaction(boolean type)
  {
    errorHandler = new UError();

    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }

    if (needReconnection == true || con_status == CON_STATUS_OUT_TRAN)
      return;

    try
    {
      clearTransactionList();
      if (client != null)
      {
        checkReconnect();
        if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
          return;

        if (!lastAutoCommit || isAutoCommitBySelf)
        {
          outBuffer.newRequest(out, UFunctionCode.END_TRANSACTION);
          outBuffer.addByte((type == true) ? END_TRAN_COMMIT
              : END_TRAN_ROLLBACK);

          UInputBuffer inBuffer;
          inBuffer = send_recv_msg(type);

          if (lastAutoCommit)
          {
            turnOffAutoCommitBySelf();
          }
        }
        if (brokerInfoKeepConnection() == false)
        { // jci 3.0
          // clientSocketClose();
        }
        delayed_close_handle = 0;
      }
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
    catch (Exception e)
    {
      errorHandler.setErrorMessage(UErrorCode.ER_UNKNOWN, e.getMessage());
    }

    /*
     * if (transactionList == null || transactionList.size() == 0)
     * errorHandler.clear();
     */

    if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR
        || brokerInfoKeepConnection() == false) // jci 3.0
    {
      if (type == false)
        errorHandler.clear();

      try
      {
        clientSocketClose();
      }
      catch (IOException e)
      {
      }
      needReconnection = true;
    }
    con_status = CON_STATUS_OUT_TRAN;
    update_executed = false;
  }

  synchronized public OutputStream getOutputStream()
  {
    return out;
  }

  /*
   * 주어진 Oid값에 의해 얻어지는 UStatement를 return한다. 주어진 Oid에 해당되는
   * object instance의 특정 attribute만을 검색할 수도 있다. Error Code :
   * ER_IS_CLOSED, ER_INVALID_ARGUMENT, ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public UStatement getByOID(CUBRIDOID oid, String[] attributeName)
  {
    UStatement returnValue = null;

    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return null;
    }
    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return null;

      outBuffer.newRequest(out, UFunctionCode.GET_BY_OID);
      outBuffer.addOID(oid);
      for (int i = 0; attributeName != null && i < attributeName.length; i++)
      {
        if (attributeName[i] != null)
          outBuffer.addStringWithNull(attributeName[i]);
        else
          outBuffer.addNull();
      }

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      returnValue = new UStatement(this, oid, attributeName, inBuffer);
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
      return null;
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
      return null;
    }
    if (returnValue.getRecentError().getErrorCode() != UErrorCode.ER_NO_ERROR)
    {
      errorHandler.copyValue(returnValue.getRecentError());
      return null;
    }
    transactionList.add(returnValue);
    return returnValue;
  }

  /*
   * CUBRID의 current product version을 가져온다. Error Code : ER_IS_CLOSED,
   * ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public String getDatabaseProductVersion()
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return null;
    }
    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return null;

      outBuffer.newRequest(out, UFunctionCode.GET_DB_VERSION);
      outBuffer.addByte(getAutoCommit() ? (byte) 1 : (byte) 0);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      return inBuffer.readString(inBuffer.remainedCapacity(),
          UJCIManager.sysCharsetName);
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
    return null;
  }

  /*
   * CUBRID의 Isolation level을 get하는 method이다. Error Code : ER_IS_CLOSED,
   * ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public int getIsolationLevel()
  {
    errorHandler = new UError();

#ifdef MMDB
    return CUBRIDIsolationLevel.TRAN_COMMIT_CLASS_UNCOMMIT_INSTANCE;
#else
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return CUBRIDIsolationLevel.TRAN_UNKNOWN_ISOLATION;
    }
    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return CUBRIDIsolationLevel.TRAN_UNKNOWN_ISOLATION;

      outBuffer.newRequest(out, UFunctionCode.GET_DB_PARAMETER);
      outBuffer.addInt(DB_PARAM_ISOLATION_LEVEL);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      return inBuffer.readInt();
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
    return CUBRIDIsolationLevel.TRAN_UNKNOWN_ISOLATION;
#endif
  }

  /*
   * class UConnection의 가장 최근에 불려진 public interface에서 발생한 error
   * 값을 얻는 method이다.
   */

  public UError getRecentError()
  {
    return errorHandler;
  }

  synchronized public String getQueryplanOnly(String sql)
  {
    String ret_val;

    if (sql == null)
      return null;

    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return null;
    }

    try
    {
      checkReconnect();
      outBuffer.newRequest(UFunctionCode.GET_QUERY_INFO);
      outBuffer.addInt(0);
      outBuffer.addByte(UStatement.QUERY_INFO_PLAN);
      outBuffer.addStringWithNull(sql);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      ret_val = inBuffer
          .readString(inBuffer.remainedCapacity(), conCharsetName);
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
      return null;
    }
    catch (IOException e)
    {
      if (errorHandler.getErrorCode() != UErrorCode.ER_CONNECTION)
        errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
      return null;
    }

    if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
    {
      return null;
    }

    return ret_val;
  }

  /*
   * Database의 Schema 정보를 가져오는 interface이다. className과
   * attributePattern는 pattern과 name이 올 수 있으며 이 때 상황에 맞게 flag값이
   * set되어야 한다. 0:No Pattern, 1:Class Pattern, 2:Attribute Pattern, 3:Both
   * Pattern Error Code : ER_IS_CLOSED, ER_SCHEMA_TYPE, ER_ILLEGAL_FLAG,
   * ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public UStatement getSchemaInfo(int type, String className,
      String attributePattern, byte flag)
  {
    UStatement returnValue = null;
    int data;

    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return null;
    }
    if (type < USchType.SCH_MIN || type > USchType.SCH_MAX)
    {
      errorHandler.setErrorCode(UErrorCode.ER_SCHEMA_TYPE);
      return null;
    }
    if (flag < 0 || flag > 3)
    {
      errorHandler.setErrorCode(UErrorCode.ER_ILLEGAL_FLAG);
      return null;
    }
    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return null;

      outBuffer.newRequest(out, UFunctionCode.GET_SCHEMA_INFO);
      outBuffer.addInt(type);
      if (className == null)
        outBuffer.addNull();
      else
        outBuffer.addStringWithNull(className);
      if (attributePattern == null)
        outBuffer.addNull();
      else
        outBuffer.addStringWithNull(attributePattern);
      outBuffer.addByte(flag);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      returnValue = new UStatement(this, className, attributePattern, type,
          inBuffer);
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
      return null;
    }
    catch (IOException e)
    {
      if (errorHandler.getErrorCode() != UErrorCode.ER_CONNECTION)
        errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
      return null;
    }
    if (returnValue.getRecentError().getErrorCode() != UErrorCode.ER_NO_ERROR)
    {
      errorHandler.copyValue(returnValue.getRecentError());
      return null;
    }
    // transactionList.add(returnValue);
    return returnValue;
  }

  /*
   * oidString에 해당되는 object instance의 attribute name이 attributeName인
   * collection type (set, multiset, sequence) attribute의 element 개수를
   * return한다. Error Code : ER_IS_CLOSED, ER_INVALID_ARGUMENT,
   * ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public int getSizeOfCollection(CUBRIDOID oid,
      String attributeName)
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return 0;
    }
    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return 0;

      outBuffer.newRequest(out, UFunctionCode.RELATED_TO_COLLECTION);
      outBuffer.addByte(this.GET_SIZE_OF_COLLECTION);
      outBuffer.addOID(oid);
      if (attributeName == null)
        outBuffer.addNull();
      else
        outBuffer.addStringWithNull(attributeName);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      return inBuffer.readInt();
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
    return 0;
  }

  synchronized public CUBRIDOID gloNew(String className, byte type,
      String filename)
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return null;
    }

    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return null;

      outBuffer.newRequest(out, UFunctionCode.GLO_NEW);
      outBuffer.addStringWithNull(className);
      outBuffer.addByte((byte) 2);
      outBuffer.addByte(type);
      if (filename == null)
        outBuffer.addNull();
      else
        outBuffer.addStringWithNull(filename);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      return (inBuffer.readOID(cubridcon));
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
    return null;
  }

  /*
   * oidString에 해당되는 object instance의 attribute name이 attributeName인
   * sequence type attribute의 attribute에 value를 index번째 element로
   * insert한다. Error Code : ER_IS_CLOSED, ER_INVALID_ARGUMENT,
   * ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public void insertElementIntoSequence(CUBRIDOID oid,
      String attributeName, int index, Object value)
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }
    try
    {
      manageElementOfSequence(oid, attributeName, index, value,
          this.INSERT_ELEMENT_INTO_SEQUENCE);
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
      return;
    }
    catch (IOException e)
    {
      if (errorHandler.getErrorCode() != UErrorCode.ER_CONNECTION)
        errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
      return;
    }
  }

  /*
   * this UConnection object가 close되었는지를 나타내는 flag를 return한다.
   */

  public boolean isClosed()
  {
    return isClosed;
  }

  /*
   * UStatement를 생성하여 SQL문을 prepare한다. prepare된 SQL문에 대해서 input
   * binding parameter에 대한 정보와, SQL문이 select일 경우 column에 대한 정보를
   * UStatement의 method를 통해 얻을 수 있다. SqlStmt가 'q1;q2;...;qn'처럼
   * 구성되어 있을 경우 얻어지는 parameter의 개수는 q1, q2, …, qn의 모든
   * parameter의 개수이다. Updatable UStatement를 만들기 위해서는 prepare시
   * isUpdatable이 true, statement type이 select이어야 하고 result set에 OID가
   * include되어져야 한다. 위의 조건에 만족하지 못할 경우 isUpdatable flag가
   * true로 set되어 있다 할지라도 read-only UStatement가 만들어진다. Error Code
   * : ER_IS_CLOSED, ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public UStatement prepare(String sqlStatement, byte prepareFlag)
  {
    return (prepare(sqlStatement, prepareFlag, false));
  }

  synchronized public UStatement prepare(String sqlStatement, byte prepareFlag,
      boolean recompile_flag)
  {
    UStatement returnValue = null;

    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return null;
    }
    try
    {
      skip_checkcas = true;
      need_checkcas = false;

      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return null;

      outBuffer.newRequest(out, UFunctionCode.PREPARE);
      outBuffer.addStringWithNull(sqlStatement);
      outBuffer.addByte(prepareFlag);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      if (recompile_flag)
        returnValue = new UStatement(this, inBuffer, true, sqlStatement,
            prepareFlag);
      else
        returnValue = new UStatement(this, inBuffer, false, sqlStatement,
            prepareFlag);
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      if (errorHandler.getErrorCode() != UErrorCode.ER_CONNECTION)
        errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
    finally
    {
      skip_checkcas = false;
    }

    if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
    {
      if (need_checkcas)
      {
        if (check_cas() == false)
        {
          try
          {
            clientSocketClose();
          }
          catch (Exception e)
          {
          }
        }
        return (prepare(sqlStatement, prepareFlag, recompile_flag));
      }
      else
      {
        return null;
      }
    }

    if (returnValue.getRecentError().getErrorCode() != UErrorCode.ER_NO_ERROR)
    {
      errorHandler.copyValue(returnValue.getRecentError());
      return null;
    }
    transactionList.add(returnValue);
    pooled_ustmts.add(returnValue);
    return returnValue;
  }

  /*
   * 주어진 oid instance에 값을 update하는 method이다. 특정 attribute만을
   * 지정하여 값을 update할 수 있다. Error Code : ER_IS_CLOSED,
   * ER_INVALID_ARGUMENT, ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public void putByOID(CUBRIDOID oid, String attributeName[],
      Object values[])
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }
    if (attributeName == null && values == null)
    {
      errorHandler.setErrorCode(UErrorCode.ER_INVALID_ARGUMENT);
      return;
    }
    try
    {
      UPutByOIDParameter putParameter = null;

      if (values != null)
        putParameter = new UPutByOIDParameter(attributeName, values);

      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return;

      outBuffer.newRequest(out, UFunctionCode.PUT_BY_OID);
      outBuffer.addOID(oid);
      if (putParameter != null)
        putParameter.writeParameter(outBuffer);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
  }

  /*
   * oidString에 해당되는 object instance의 attribute name이 attributeName인
   * sequence type attribute에 value를 index번째 element로 replace한다. Error
   * Code : ER_IS_CLOSED, ER_INVALID_ARGUMENT, ER_ILLEGAL_DATA_SIZE,
   * ER_COMMUNICATION
   */

  synchronized public void putElementInSequence(CUBRIDOID oid,
      String attributeName, int index, Object value)
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }
    try
    {
      manageElementOfSequence(oid, attributeName, index, value,
          this.PUT_ELEMENT_ON_SEQUENCE);
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
      return;
    }
    catch (IOException e)
    {
      if (errorHandler.getErrorCode() != UErrorCode.ER_CONNECTION)
        errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
      return;
    }
  }

  /*
   * Database의 Isolation level을 set하는 method이다. Isolation level은
   * CUBRIDIsolationLevel에서 Set한 범위 내에 포함되어야 한다. Error Code :
   * ER_IS_CLOSED, ER_ISO_TYPE, ER_ILLEGAL_DATA_SIZE, ER_COMMUNICATION
   */

  synchronized public void setIsolationLevel(int level)
  {
    errorHandler = new UError();

#ifndef MMDB
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }
    if (level < CUBRIDIsolationLevel.TRAN_MIN
        || level > CUBRIDIsolationLevel.TRAN_MAX)
    {
      errorHandler.setErrorCode(UErrorCode.ER_ISO_TYPE);
      return;
    }
    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return;

      outBuffer.newRequest(out, UFunctionCode.SET_DB_PARAMETER);
      outBuffer.addInt(DB_PARAM_ISOLATION_LEVEL);
      outBuffer.addInt(level);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      lastIsolationLevel = level;
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
#endif
  }

  synchronized public void setLockTimeout(int timeout)
  {
    errorHandler = new UError();

    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }

    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return;

      outBuffer.newRequest(out, UFunctionCode.SET_DB_PARAMETER);
      outBuffer.addInt(DB_PARAM_LOCK_TIMEOUT);
      outBuffer.addInt(timeout);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      if (timeout < 0)
        lastLockTimeout = LOCK_TIMEOUT_INFINITE;
      else
        lastLockTimeout = timeout;
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
  }

  /*
   * 3.0 synchronized public void savepoint(int mode, String name) {
   * errorHandler = new UError(); if (isClosed == true) {
   * errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED); return; }
   * 
   * try { checkReconnect(); if (errorHandler.getErrorCode() !=
   * UErrorCode.ER_NO_ERROR) return;
   * 
   * outBuffer.newRequest(out, UFunctionCode.SAVEPOINT);
   * outBuffer.addByte(mode); outBuffer.addStringWithNull(name);
   * 
   * UInputBuffer inBuffer; inBuffer = send_recv_msg(); } catch (UJciException
   * e) { e.toUError(errorHandler); } catch (IOException e) {
   * errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION); } }
   */

  synchronized public byte getDbmsType()
  {
    // jci 3.0
    if (broker_info == null)
      return DBMS_CUBRID;
    return broker_info[0];

    /*
     * jci 2.x return DBMS_CUBRID;
     */
  }

  public boolean brokerInfoStatementPooling()
  {
    if (broker_info == null)
      return false;

    if (broker_info[2] == (byte) 1)
      return true;
    else
      return false;
  }

  synchronized public void xa_endTransaction(Xid xid, boolean type)
  {
    errorHandler = new UError();

    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }

    try
    {
      clearTransactionList();
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return;

      outBuffer.newRequest(out, UFunctionCode.XA_END_TRAN);
      outBuffer.addXid(xid);
      outBuffer.addByte((type == true) ? END_TRAN_COMMIT : END_TRAN_ROLLBACK);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();
    }
    catch (Exception e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_UNKNOWN);
    }
    finally
    {
      try
      {
        clientSocketClose();
        needReconnection = true;
      }
      catch (IOException e)
      {
      }
    }
  }

  synchronized public void xa_prepare(Xid xid)
  {
    errorHandler = new UError();

    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return;
    }

    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return;

      outBuffer.newRequest(out, UFunctionCode.XA_PREPARE);
      outBuffer.addXid(xid);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();
    }
    catch (Exception e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_UNKNOWN);
    }
  }

  synchronized public Xid[] xa_recover()
  {
    errorHandler = new UError();

    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return null;
    }

    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return null;

      outBuffer.newRequest(out, UFunctionCode.XA_RECOVER);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      int num_xid = inBuffer.getResCode();

      CUBRIDXid[] xid;
      xid = new CUBRIDXid[num_xid];
      for (int i = 0; i < num_xid; i++)
      {
        xid[i] = inBuffer.readXid();
      }
      return xid;
    }
    catch (Exception e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_UNKNOWN);
      return null;
    }
  }

  public void setCUBRIDConnection(CUBRIDConnection con)
  {
    cubridcon = con;
    lastIsolationLevel = CUBRIDIsolationLevel.TRAN_UNKNOWN_ISOLATION;
    lastLockTimeout = LOCK_TIMEOUT_NOT_USED;
  }

  public CUBRIDConnection getCUBRIDConnection()
  {
    return cubridcon;
  }

  synchronized public boolean check_cas()
  {
    if (isClosed == true)
      return true;
    if (client == null || needReconnection == true)
      return true;

    if (skip_checkcas)
    {
      need_checkcas = true;
      return true;
    }

    try
    {
      synchronized (in)
      {
        if (checkCasMsg == null)
        {
          int msgSize = 1;
          checkCasMsg = new byte[5];
          checkCasMsg[0] = (byte) ((msgSize >>> 24) & 0xFF);
          checkCasMsg[1] = (byte) ((msgSize >>> 16) & 0xFF);
          checkCasMsg[2] = (byte) ((msgSize >>> 8) & 0xFF);
          checkCasMsg[3] = (byte) ((msgSize >>> 0) & 0xFF);
          checkCasMsg[4] = UFunctionCode.CHECK_CAS;
        }

        output.write(checkCasMsg);
        int res = input.readInt();
        if (res == 0) /* yaw */
          return true;
        if (res < 4)
          return false;
        res = input.readInt();
        if (res < 0)
          return false;
      }
    }
    catch (IOException e)
    {
      return false;
    }

    return true;
  }

#ifdef SEND_APP_INFO
  synchronized public boolean check_cas(String msg)
  {
    try
    {
      outBuffer.newRequest(out, UFunctionCode.CHECK_CAS);
      outBuffer.addStringWithNull(msg);
      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();
    }
    catch (Exception e)
    {
      return false;
    }

    return true;
  }

#endif

  synchronized public void reset_connection()
  {
    try
    {
      if (client != null)
        client.close();
    }
    catch (Exception e)
    {
    }

    client = null;
    needReconnection = true;
  }

  synchronized public Object oidCmd(CUBRIDOID oid, byte cmd)
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return null;
    }
    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return null;

      outBuffer.newRequest(out, UFunctionCode.RELATED_TO_OID);
      outBuffer.addByte(cmd);
      outBuffer.addOID(oid);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      int res_code;
      res_code = inBuffer.getResCode();

      if (cmd == IS_INSTANCE || cmd == IS_GLO_INSTANCE)
      {
        if (res_code == 1)
          return oid;
      }
      else if (cmd == GET_CLASS_NAME_BY_OID)
      {
        return inBuffer.readString(inBuffer.remainedCapacity(), conCharsetName);
      }
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }

    return null;
  }

  synchronized public int gloCmd(CUBRIDOID oid, byte cmd, int pos, int len,
      byte[] buf, int start)
  {
    errorHandler = new UError();
    if (isClosed == true)
    {
      errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED);
      return 0;
    }
    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return 0;

      outBuffer.newRequest(out, UFunctionCode.GLO_CMD);
      outBuffer.addByte(cmd);
      outBuffer.addOID(oid);

      if (cmd == GLO_CMD_DATA_SIZE)
      {
      }
      else if (cmd == GLO_CMD_READ_DATA || cmd == GLO_CMD_DELETE_DATA)
      {
        outBuffer.addInt(pos);
        outBuffer.addInt(len);
      }
      else if (cmd == GLO_CMD_WRITE_DATA || cmd == GLO_CMD_INSERT_DATA
          || cmd == GLO_CMD_BINARY_SEARCH)
      {
        outBuffer.addInt(pos);
        outBuffer.addBytes(buf, start, len);
      }
      else if (cmd == GLO_CMD_TRUNCATE_DATA)
      {
        outBuffer.addInt(pos);
      }
      else
      {
      }

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();

      int res_code;
      res_code = inBuffer.getResCode();

      if (cmd == GLO_CMD_READ_DATA)
        inBuffer.readBytes(buf, start, res_code);
      else if (cmd == GLO_CMD_BINARY_SEARCH)
        res_code = inBuffer.readInt();

      return res_code;
    }
    catch (UJciException e)
    {
      e.toUError(errorHandler);
    }
    catch (IOException e)
    {
      errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION);
    }
    return 0;
  }

  synchronized public void setAutoCommit(boolean autoCommit)
  {
#ifndef SERVER_SIDE_JDBC
    if (lastAutoCommit != autoCommit)
    {
      lastAutoCommit = autoCommit;
    }
#endif
    /*
     * errorHandler = new UError(); if (isClosed == true){
     * errorHandler.setErrorCode(UErrorCode.ER_IS_CLOSED); return; } try{
     * checkReconnect(); if (errorHandler.getErrorCode() !=
     * UErrorCode.ER_NO_ERROR) return; outBuffer.newRequest(out,
     * UFunctionCode.SET_DB_PARAMETER); outBuffer.addInt(DB_PARAM_AUTO_COMMIT);
     * outBuffer.addInt(autoCommit ? 1 : 0 ); UInputBuffer inBuffer; inBuffer =
     * send_recv_msg(); lastAutoCommit = autoCommit; }catch(UJciException e){
     * e.toUError(errorHandler); }catch(IOException e){
     * errorHandler.setErrorCode(UErrorCode.ER_COMMUNICATION); }
     */
  }

  public boolean getAutoCommit()
  {
    return lastAutoCommit;
  }

  public int currentIsolationLevel()
  {
    return lastIsolationLevel;
  }

  void clientSocketClose() throws IOException
  {
    try
    {
      needReconnection = true;
      if (client != null)
      {
        client.setSoLinger(true, 0);
        client.close();
      }
      client = null;
    }
    catch (IOException e)
    {
    }
    clearPooledUStatements();
  }

  UInputBuffer send_recv_msg(boolean recv_result) throws UJciException,
      IOException
  {
    outBuffer.sendData();
    if (recv_result)
      return (new UInputBuffer(in));
    else
      return null;
  }

  UInputBuffer send_recv_msg() throws UJciException, IOException
  {
    return (send_recv_msg(true));
  }

  void cancel() throws UJciException, IOException
  {
    UConnection conCancel = null;
    try
    {
      conCancel = new UConnection(CASIp, CASPort);

      String cancel_msg = "CANCEL";
      conCancel.output.write(cancel_msg.getBytes());
      conCancel.output.writeInt(processId);
      conCancel.output.flush();

      int error = conCancel.input.readInt();

      if (error < 0)
        throw new UJciException(UErrorCode.ER_DBMS, error, null);
    }
    finally
    {
      if (conCancel != null)
      {
        conCancel.clientSocketClose();
        conCancel.close();
      }
    }
  }

  UUrlCache getUrlCache()
  {
    if (url_cache == null)
    {
      UUrlHostKey key = new UUrlHostKey(CASIp, CASPort, dbname, user);
      url_cache = UJCIManager.getUrlCache(key);
    }
    return url_cache;
  }

  /*
   * endTransaction이 일어나 CAS와 connection이 단절되었을 때 다시 CAS와의
   * connection을 만들어주는 method이다.
   */

  private void reconnect() throws IOException, UJciException
  {
    initConnection(CASIp, CASPort);
    sendDriverInfo();
    whetherConnectOtherPortOrNot();
    connectDB();
    needReconnection = false;
    if (lastIsolationLevel != CUBRIDIsolationLevel.TRAN_UNKNOWN_ISOLATION)
      setIsolationLevel(lastIsolationLevel);
    if (lastLockTimeout != LOCK_TIMEOUT_NOT_USED)
      setLockTimeout(lastLockTimeout);
    /*
     * if(!lastAutoCommit) setAutoCommit(lastAutoCommit);
     */

  }

  // jci 3.0
  private boolean brokerInfoKeepConnection()
  {
    if (broker_info == null)
      return false;

    if (broker_info[1] == (byte) 1)
      return true;
    else
      return false;
  }

  /* Database와의 connection을 만드는 method이다. */

  private void connectDB() throws IOException, UJciException
  {
    UInputBuffer inBuffer;

    synchronized (output)
    {
      output.write(dbInfo);
      output.flush();

      synchronized (input)
      {
        synchronized (in)
        {
          inBuffer = new UInputBuffer(in);
          processId = inBuffer.getResCode();
          if (inBuffer.remainedCapacity() >= 4)
          {
            if (broker_info == null)
              broker_info = new byte[4];
            inBuffer.readBytes(broker_info);
          }
        }
      }
    }
  }

  /*
   * CAS와의 connection을 만드는 부분이다.
   */

  private void initConnection(String ip, int port) throws UJciException
  {
    try
    {
      client = new Socket(InetAddress.getByName(ip), port);
      client.setTcpNoDelay(true);

      out = client.getOutputStream();
      output = new DataOutputStream(client.getOutputStream());
      out.flush();
      output.flush();

      in = client.getInputStream();
      input = new DataInputStream(client.getInputStream());
    }
    catch (IOException e)
    {
      throw new UJciException(UErrorCode.ER_CONNECTION);
    }
  }

  /*
   * oidString에 해당되는 object instance의 attribute name이 attributeName인
   * sequence type attribute에 행해지는 operation들의 공통된 부분이다.
   * insertElementIntoSequence, putElementInSequence에서 call한다.
   */

  private void manageElementOfSequence(CUBRIDOID oid, String attributeName,
      int index, Object value, byte flag) throws UJciException, IOException
  {
    UAParameter aParameter;
    aParameter = new UAParameter(attributeName, value);

    checkReconnect();
    if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
      return;

    outBuffer.newRequest(out, UFunctionCode.RELATED_TO_COLLECTION);
    outBuffer.addByte(flag);
    outBuffer.addOID(oid);
    outBuffer.addInt(index);
    aParameter.writeParameter(outBuffer);

    UInputBuffer inBuffer;
    inBuffer = send_recv_msg();
  }

  /*
   * oidString에 해당되는 object instance의 attribute name이 attributeName인 set
   * type attribute에 행해지는 operation들의 공통된 부분이다. addElementToSet,
   * dropElementInSet에서 call한다.
   */

  private void manageElementOfSet(CUBRIDOID oid, String attributeName,
      Object value, byte flag) throws UJciException, IOException
  {
    UAParameter aParameter;
    aParameter = new UAParameter(attributeName, value);

    checkReconnect();
    if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
      return;

    outBuffer.newRequest(out, UFunctionCode.RELATED_TO_COLLECTION);
    outBuffer.addByte(flag);
    outBuffer.addOID(oid);
    aParameter.writeParameter(outBuffer);

    UInputBuffer inBuffer;
    inBuffer = send_recv_msg();
  }

  /*
   * CAS에 보낼 data들을 저장해 놓을 buffer를 준비하는 method이다.
   */

  void checkReconnect() throws IOException, UJciException
  {
    if (dbInfo == null)
    {
      dbInfo = new byte[96];
      UJCIUtil.copy_byte(dbInfo, 0, 32, dbname);
      UJCIUtil.copy_byte(dbInfo, 32, 32, user);
      UJCIUtil.copy_byte(dbInfo, 64, 32, passwd);
      dbInfo[dbInfo.length - 1] = (byte) 0;
    }

    if (outBuffer == null)
    {
      outBuffer = new UOutputBuffer(this);
    }

    if (transactionList == null)
    {
      transactionList = new Vector();
    }
    if (pooled_ustmts == null)
    {
      pooled_ustmts = new Vector();
    }

    if (!isServerSideJdbc)
    {
      if (con_status == CON_STATUS_OUT_TRAN && check_cas() == false)
      {
        clientSocketClose();
      }

      if (needReconnection == true)
      {
        reconnect();
#ifdef SEND_APP_INFO
        sendAppInfo();
#endif
      }
    }
    con_status = CON_STATUS_IN_TRAN;
  }

#ifdef SEND_APP_INFO
  private void sendAppInfo()
  {
    String msg;
    msg = CUBRIDJdbcInfoTable.getValue();
    if (msg == null)
      return;
    check_cas(msg);
  }

#endif

  /*
   * server쪽에 JDBC Driver info를 넘겨준다.
   */

  private void sendDriverInfo() throws IOException
  {
    synchronized (output)
    {
      output.write(driverInfo);
      output.flush();
    }
  }

  /*
   * server와의 connection을 만들 때 server쪽에서 새로운 port number가 넘어오지
   * 않으면 현재의 connection을 계속 사용하고 새로운 port number가 넘어오면
   * 새로운 port로 server쪽과 connection을 다시 만드는 부분이다.
   */

  private void whetherConnectOtherPortOrNot() throws IOException, UJciException
  {
    int newPort = 0;

    synchronized (input)
    {
      newPort = input.readInt();
    }
    if (newPort < 0)
    {
      throw new UJciException(UErrorCode.ER_DBMS, newPort, null);
    }
    else if (newPort == 0)
      return;
    client.setSoLinger(true, 0);
    client.close();
    initConnection(CASIp, newPort);
  }

  // jci 3.0
  private void disconnect()
  {
    try
    {
      checkReconnect();
      if (errorHandler.getErrorCode() != UErrorCode.ER_NO_ERROR)
        return;

      outBuffer.newRequest(out, UFunctionCode.CON_CLOSE);

      UInputBuffer inBuffer;
      inBuffer = send_recv_msg();
    }
    catch (Exception e)
    {
    }
  }

  private void clearTransactionList()
  {
    if (transactionList == null)
      return;
#if 0
    try
    {
      while (transactionList.isEmpty() != true)
      {
        UStatement willBeDeleted = (UStatement) transactionList.remove(0);
        if (willBeDeleted != null)
        {
          synchronized (willBeDeleted)
          {
            willBeDeleted.close();
          }
        }
      }
    }
    catch (Exception e)
    {
    }
    finally
    {
      transactionList.clear();
    }
#endif
    transactionList.clear();
  }

  // end jci 3.0

  private void clearPooledUStatements()
  {
    if (pooled_ustmts == null)
      return;

    while (pooled_ustmts.isEmpty() != true)
    {
      UStatement tmp_ustmt = (UStatement) pooled_ustmts.remove(0);
      if (tmp_ustmt != null)
        tmp_ustmt.close(false);
    }
  }

  public boolean isServerSideJdbc()
  {
    return isServerSideJdbc;
  }

  public void turnOnAutoCommitBySelf()
  {
    isAutoCommitBySelf = true;
  }

  public void turnOffAutoCommitBySelf()
  {
    isAutoCommitBySelf = false;
  }
}
